diff --git a/frameworks/base/telephony/java/com/android/internal/telephony/ITelephony.aidl b/frameworks/base/telephony/java/com/android/internal/telephony/ITelephony.aidl
index 584411b..ecd26f6 100644
--- a/frameworks/base/telephony/java/com/android/internal/telephony/ITelephony.aidl
+++ b/frameworks/base/telephony/java/com/android/internal/telephony/ITelephony.aidl
@@ -304,5 +304,40 @@ interface ITelephony {
      * Sets minimum time in milli-seconds between onCellInfoChanged
      */
     void setCellInfoListRate(int rateInMillis);
+
+    /**
+     * Returns the response APDU for a command APDU sent to a logical channel
+     */
+    String transmitIccLogicalChannel(int cla, int command, int channel,
+            int p1, int p2, int p3, String data);
+
+    /**
+     * Returns the response APDU for a command APDU sent to the basic channel
+     */
+    String transmitIccBasicChannel(int cla, int command,
+            int p1, int p2, int p3, String data);
+
+    /**
+     * Returns the channel id of the logical channel,
+     * Returns 0 on error.
+     */
+    int openIccLogicalChannel(String AID);
+
+    /**
+     * Return true if logical channel was closed successfully
+     */
+    boolean closeIccLogicalChannel(int channel);
+
+    /**
+     * Returns the error code of the last error occured.
+     * Currently only used for openIccLogicalChannel
+     */
+    int getLastError();
+
+    /**
+     * Returns the response APDU for a command APDU sent through SIM_IO
+     */
+    byte[] transmitIccSimIO(int fileID, int command,
+                                      int p1, int p2, int p3, String filePath);
 }
 
diff --git a/frameworks/base/telephony/java/com/android/internal/telephony/RILConstants.java b/frameworks/base/telephony/java/com/android/internal/telephony/RILConstants.java
index 9650b99..7c6583b 100644
--- a/frameworks/base/telephony/java/com/android/internal/telephony/RILConstants.java
+++ b/frameworks/base/telephony/java/com/android/internal/telephony/RILConstants.java
@@ -55,6 +55,10 @@ public interface RILConstants {
     int ILLEGAL_SIM_OR_ME = 15;               /* network selection failure due
                                                  to wrong SIM/ME and no
                                                  retries needed */
+    int MISSING_RESOURCE = 16;
+    int NO_SUCH_ELEMENT = 17;
+    int INVALID_PARAMETER = 18;
+
 
     /* NETWORK_MODE_* See ril.h RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE */
     int NETWORK_MODE_WCDMA_PREF     = 0; /* GSM/WCDMA (WCDMA preferred) */
@@ -262,6 +266,10 @@ cat include/telephony/ril.h | \
     int RIL_REQUEST_VOICE_RADIO_TECH = 108;
     int RIL_REQUEST_GET_CELL_INFO_LIST = 109;
     int RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE = 110;
+    int RIL_REQUEST_SIM_TRANSMIT_BASIC = 111;
+    int RIL_REQUEST_SIM_OPEN_CHANNEL = 112;
+    int RIL_REQUEST_SIM_CLOSE_CHANNEL = 113;
+    int RIL_REQUEST_SIM_TRANSMIT_CHANNEL = 114;
     int RIL_UNSOL_RESPONSE_BASE = 1000;
     int RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED = 1000;
     int RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED = 1001;
diff --git a/frameworks/opt/telephony/src/java/com/android/internal/telephony/CommandException.java b/frameworks/opt/telephony/src/java/com/android/internal/telephony/CommandException.java
index 550e91c..229f0c1 100644
--- a/frameworks/opt/telephony/src/java/com/android/internal/telephony/CommandException.java
+++ b/frameworks/opt/telephony/src/java/com/android/internal/telephony/CommandException.java
@@ -42,6 +42,9 @@ public class CommandException extends RuntimeException {
         MODE_NOT_SUPPORTED,
         FDN_CHECK_FAILURE,
         ILLEGAL_SIM_OR_ME,
+        MISSING_RESOURCE,
+        NO_SUCH_ELEMENT,
+        INVALID_PARAMETER,
     }
 
     public CommandException(Error e) {
@@ -83,6 +86,12 @@ public class CommandException extends RuntimeException {
                 return new CommandException(Error.FDN_CHECK_FAILURE);
             case RILConstants.ILLEGAL_SIM_OR_ME:
                 return new CommandException(Error.ILLEGAL_SIM_OR_ME);
+            case RILConstants.MISSING_RESOURCE:
+                return new CommandException(Error.MISSING_RESOURCE);
+            case RILConstants.NO_SUCH_ELEMENT:
+                return new CommandException(Error.NO_SUCH_ELEMENT);
+            case RILConstants.INVALID_PARAMETER:
+                return new CommandException(Error.INVALID_PARAMETER);
             default:
                 Rlog.e("GSM", "Unrecognized RIL errno " + ril_errno);
                 return new CommandException(Error.INVALID_RESPONSE);
diff --git a/frameworks/opt/telephony/src/java/com/android/internal/telephony/CommandsInterface.java b/frameworks/opt/telephony/src/java/com/android/internal/telephony/CommandsInterface.java
index d4ffe20..887c679 100644
--- a/frameworks/opt/telephony/src/java/com/android/internal/telephony/CommandsInterface.java
+++ b/frameworks/opt/telephony/src/java/com/android/internal/telephony/CommandsInterface.java
@@ -1141,6 +1141,18 @@ public interface CommandsInterface {
 
     void setNetworkSelectionModeManual(String operatorNumeric, Message response);
 
+
+    /**
+     * SmartCard API related exports
+     */
+    void iccExchangeAPDU(int cla, int command, int channel, int p1, int p2,
+            int p3, String data, Message response);
+
+    void iccOpenChannel(String AID, Message response);
+
+    void iccCloseChannel(int channel, Message response);
+
+
     /**
      * Queries whether the current network selection mode is automatic
      * or manual
diff --git a/frameworks/opt/telephony/src/java/com/android/internal/telephony/IccCard.java b/frameworks/opt/telephony/src/java/com/android/internal/telephony/IccCard.java
index 1ec4f18..5638259 100644
--- a/frameworks/opt/telephony/src/java/com/android/internal/telephony/IccCard.java
+++ b/frameworks/opt/telephony/src/java/com/android/internal/telephony/IccCard.java
@@ -214,4 +214,14 @@ public interface IccCard {
      * @return true if a ICC card is present
      */
     public boolean hasIccCard();
+
+    public void exchangeAPDU(int cla, int command, int channel, int p1, int p2,
+            int p3, String data, Message onComplete);
+
+    public void openLogicalChannel(String AID, Message onComplete);
+
+    public void closeLogicalChannel(int channel, Message onComplete);
+    
+	public void exchangeSimIO(int fileID, int command,
+                              int p1, int p2, int p3, String pathID, Message onComplete);    
 }
diff --git a/frameworks/opt/telephony/src/java/com/android/internal/telephony/RIL.java b/frameworks/opt/telephony/src/java/com/android/internal/telephony/RIL.java
index 1a719d6..0a64ff9 100644
--- a/frameworks/opt/telephony/src/java/com/android/internal/telephony/RIL.java
+++ b/frameworks/opt/telephony/src/java/com/android/internal/telephony/RIL.java
@@ -2339,6 +2339,10 @@ public final class RIL extends BaseCommands implements CommandsInterface {
             case RIL_REQUEST_SEND_SMS_EXPECT_MORE: ret =  responseSMS(p); break;
             case RIL_REQUEST_SETUP_DATA_CALL: ret =  responseSetupDataCall(p); break;
             case RIL_REQUEST_SIM_IO: ret =  responseICC_IO(p); break;
+            case RIL_REQUEST_SIM_TRANSMIT_BASIC: ret =  responseICC_IO(p); break;
+            case RIL_REQUEST_SIM_OPEN_CHANNEL: ret  = responseInts(p); break;
+            case RIL_REQUEST_SIM_CLOSE_CHANNEL: ret  = responseVoid(p); break;
+            case RIL_REQUEST_SIM_TRANSMIT_CHANNEL: ret = responseICC_IO(p); break;
             case RIL_REQUEST_SEND_USSD: ret =  responseVoid(p); break;
             case RIL_REQUEST_CANCEL_USSD: ret =  responseVoid(p); break;
             case RIL_REQUEST_GET_CLIR: ret =  responseInts(p); break;
@@ -3638,6 +3642,10 @@ public final class RIL extends BaseCommands implements CommandsInterface {
             case RIL_REQUEST_SEND_SMS_EXPECT_MORE: return "SEND_SMS_EXPECT_MORE";
             case RIL_REQUEST_SETUP_DATA_CALL: return "SETUP_DATA_CALL";
             case RIL_REQUEST_SIM_IO: return "SIM_IO";
+            case RIL_REQUEST_SIM_TRANSMIT_BASIC: return "SIM_TRANSMIT_BASIC";
+            case RIL_REQUEST_SIM_OPEN_CHANNEL: return "SIM_OPEN_CHANNEL";
+            case RIL_REQUEST_SIM_CLOSE_CHANNEL: return "SIM_CLOSE_CHANNEL";
+            case RIL_REQUEST_SIM_TRANSMIT_CHANNEL: return "SIM_TRANSMIT_CHANNEL";
             case RIL_REQUEST_SEND_USSD: return "SEND_USSD";
             case RIL_REQUEST_CANCEL_USSD: return "CANCEL_USSD";
             case RIL_REQUEST_GET_CLIR: return "GET_CLIR";
@@ -4068,4 +4076,63 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         pw.println(" mLastNITZTimeInfo=" + mLastNITZTimeInfo);
         pw.println(" mTestingEmergencyCall=" + mTestingEmergencyCall.get());
     }
+
+    public void
+    iccExchangeAPDU(int cla, int command, int channel, int p1, int p2, int p3,
+            String data, Message result) {
+        RILRequest rr;
+        if (channel == 0) {
+            rr = RILRequest.obtain(RIL_REQUEST_SIM_TRANSMIT_BASIC, result);
+        } else {
+            rr = RILRequest.obtain(RIL_REQUEST_SIM_TRANSMIT_CHANNEL, result);
+        }
+
+        rr.mParcel.writeInt(cla);
+        rr.mParcel.writeInt(command);
+        rr.mParcel.writeInt(channel);
+        rr.mParcel.writeString(null);
+        rr.mParcel.writeInt(p1);
+        rr.mParcel.writeInt(p2);
+        rr.mParcel.writeInt(p3);
+        rr.mParcel.writeString(data);
+        rr.mParcel.writeString(null);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> iccExchangeAPDU: " + requestToString(rr.mRequest)
+                + "Channel 0x" + Integer.toHexString(channel) + ": "
+                + " 0x" + Integer.toHexString(cla)
+                + " 0x" + Integer.toHexString(command)
+                + " 0x" + Integer.toHexString(p1)
+                + " 0x" + Integer.toHexString(p2)
+                + " 0x" + Integer.toHexString(p3)
+                );
+
+        send(rr);
+    }
+
+    public void
+    iccOpenChannel(String AID, Message result) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SIM_OPEN_CHANNEL, result);
+
+        rr.mParcel.writeString(AID);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> iccOpenChannel: " + requestToString(rr.mRequest)
+                + " " + AID);
+
+        send(rr);
+    }
+
+    public void
+    iccCloseChannel(int channel, Message result) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SIM_CLOSE_CHANNEL, result);
+    
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(channel);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> iccCloseChannel: " + requestToString(rr.mRequest)
+                + " " + channel);
+
+        send(rr);
+    }
 }
diff --git a/frameworks/opt/telephony/src/java/com/android/internal/telephony/sip/SipCommandInterface.java b/frameworks/opt/telephony/src/java/com/android/internal/telephony/sip/SipCommandInterface.java
index 8ed1566..4c38c4c 100644
--- a/frameworks/opt/telephony/src/java/com/android/internal/telephony/sip/SipCommandInterface.java
+++ b/frameworks/opt/telephony/src/java/com/android/internal/telephony/sip/SipCommandInterface.java
@@ -536,4 +536,14 @@ class SipCommandInterface extends BaseCommands implements CommandsInterface {
     @Override
     public void setCellInfoListRate(int rateInMillis, Message response) {
     }
+
+    public void iccExchangeAPDU(int cla, int command, int channel, int p1,
+            int p2, int p3, String data, Message response) {
+    }
+
+    public void iccOpenChannel(String AID, Message response) {
+    }
+
+    public void iccCloseChannel(int channel, Message response) {
+    }
 }
diff --git a/frameworks/opt/telephony/src/java/com/android/internal/telephony/test/SimulatedCommands.java b/frameworks/opt/telephony/src/java/com/android/internal/telephony/test/SimulatedCommands.java
index 3532670..0ed3ac7 100644
--- a/frameworks/opt/telephony/src/java/com/android/internal/telephony/test/SimulatedCommands.java
+++ b/frameworks/opt/telephony/src/java/com/android/internal/telephony/test/SimulatedCommands.java
@@ -1655,4 +1655,17 @@ public final class SimulatedCommands extends BaseCommands
     public void setCellInfoListRate(int rateInMillis, Message response) {
         unimplemented(response);
     }
+
+    public void iccExchangeAPDU (int cla, int command, int channel, int p1,
+                         int p2, int p3, String data, Message response) {
+        unimplemented(response);
+    }
+
+    public void iccOpenChannel(String AID, Message response) {
+        unimplemented(response);
+    }
+
+    public void iccCloseChannel(int channel, Message response) {
+        unimplemented(response);
+    }
 }
diff --git a/frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/IccCardProxy.java b/frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/IccCardProxy.java
index 733af64..90ade88 100644
--- a/frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/IccCardProxy.java
+++ b/frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/IccCardProxy.java
@@ -742,4 +742,38 @@ public class IccCardProxy extends Handler implements IccCard {
 
         pw.flush();
     }
+
+    public void exchangeAPDU(int cla, int command, int channel, int p1, int p2,
+            int p3, String data, Message onComplete) {
+        synchronized (mLock) {
+            if (mUiccApplication != null) {
+                mUiccApplication.exchangeAPDU(cla,command,channel,p1,p2,p3,data,onComplete);
+            }         
+		}
+    }
+
+    public void openLogicalChannel(String AID, Message onComplete) {
+        synchronized (mLock) {
+            if (mUiccApplication != null) {
+                mUiccApplication.openLogicalChannel(AID,onComplete);
+            }         
+		}
+	}
+    
+    public void closeLogicalChannel(int channel, Message onComplete) {
+        synchronized (mLock) {
+            if (mUiccApplication != null) {
+                mUiccApplication.closeLogicalChannel(channel,onComplete);
+            }         
+		}
+    }
+    
+    public void exchangeSimIO(int fileID, int command,
+                                           int p1, int p2, int p3, String pathID, Message onComplete) {
+        synchronized (mLock) {
+            if (mUiccApplication != null) {
+				mUiccApplication.exchangeSimIO(fileID,command,p1,p2,p3,pathID,onComplete);
+			}
+		}
+	}    
 }
diff --git a/frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/UiccCardApplication.java b/frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/UiccCardApplication.java
index 0715b0e..90aef7c 100644
--- a/frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/UiccCardApplication.java
+++ b/frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/UiccCardApplication.java
@@ -44,7 +44,11 @@ public class UiccCardApplication {
     private static final int EVENT_CHANGE_FACILITY_FDN_DONE = 2;
     private static final int EVENT_QUERY_FACILITY_LOCK_DONE = 3;
     private static final int EVENT_CHANGE_FACILITY_LOCK_DONE = 4;
-
+    private static final int EVENT_EXCHANGE_APDU_DONE = 5;
+    private static final int EVENT_OPEN_CHANNEL_DONE = 6;
+    private static final int EVENT_CLOSE_CHANNEL_DONE = 7;
+	private static final int EVENT_SIM_IO_DONE = 8;
+ 
     private final Object  mLock = new Object();
     private UiccCard      mUiccCard; //parent
     private AppState      mAppState;
@@ -337,6 +341,18 @@ public class UiccCardApplication {
                     ar = (AsyncResult)msg.obj;
                     onChangeFacilityLock(ar);
                     break;
+                case EVENT_EXCHANGE_APDU_DONE:
+                case EVENT_OPEN_CHANNEL_DONE:
+                case EVENT_CLOSE_CHANNEL_DONE:
+				case EVENT_SIM_IO_DONE:                
+                    ar = (AsyncResult)msg.obj;
+                    if(ar.exception != null) {
+                       if (DBG) log("Error in SIM access with exception" + ar.exception);
+                    }
+                    AsyncResult.forMessage(((Message)ar.userObj),
+                            ar.result, ar.exception);
+                    ((Message)ar.userObj).sendToTarget();
+                    break;
                 default:
                     loge("Unknown Event " + msg.what);
             }
@@ -735,4 +751,26 @@ public class UiccCardApplication {
         }
         pw.flush();
     }
+
+    public void exchangeAPDU(int cla, int command, int channel, int p1, int p2,
+            int p3, String data, Message onComplete) {
+        mCi.iccExchangeAPDU(cla, command, channel, p1, p2, p3, data,
+                mHandler.obtainMessage(EVENT_EXCHANGE_APDU_DONE, onComplete));
+    }
+
+    public void openLogicalChannel(String AID, Message onComplete) {
+        mCi.iccOpenChannel(AID,
+                mHandler.obtainMessage(EVENT_OPEN_CHANNEL_DONE, onComplete));
+    }
+
+    public void closeLogicalChannel(int channel, Message onComplete) {
+        mCi.iccCloseChannel(channel,
+                mHandler.obtainMessage(EVENT_CLOSE_CHANNEL_DONE, onComplete));
+    }
+    
+    public void exchangeSimIO(int fileID, int command,
+                              int p1, int p2, int p3, String pathID, Message onComplete) {
+		mCi.iccIO(command,fileID,pathID,p1,p2,p3,null,null,
+			mHandler.obtainMessage(EVENT_SIM_IO_DONE, onComplete));
+	}								  
 }
diff --git a/frameworks/opt/telephony/tests/telephonytests/src/com/android/internal/telephony/gsm/UsimDataDownloadCommands.java b/frameworks/opt/telephony/tests/telephonytests/src/com/android/internal/telephony/gsm/UsimDataDownloadCommands.java
index cd0fad3..be5ce23 100644
--- a/frameworks/opt/telephony/tests/telephonytests/src/com/android/internal/telephony/gsm/UsimDataDownloadCommands.java
+++ b/frameworks/opt/telephony/tests/telephonytests/src/com/android/internal/telephony/gsm/UsimDataDownloadCommands.java
@@ -630,4 +630,17 @@ class UsimDataDownloadCommands extends BaseCommands {
     public void iccIOForApp(int command, int fileid, String path, int p1, int p2, int p3,
             String data, String pin2, String aid, Message response) {
     }
+
+    @Override
+    public void iccExchangeAPDU (int cla, int command, int channel, int p1,
+                         int p2, int p3, String data, Message response) {
+    }
+
+    @Override
+    public void iccOpenChannel(String AID, Message response) {
+    }
+
+    @Override
+    public void iccCloseChannel(int channel, Message response) {
+    }
 }
diff --git a/packages/apps/Phone/src/com/android/phone/PhoneInterfaceManager.java b/packages/apps/Phone/src/com/android/phone/PhoneInterfaceManager.java
index 6600ae5..2ae6739 100644
--- a/packages/apps/Phone/src/com/android/phone/PhoneInterfaceManager.java
+++ b/packages/apps/Phone/src/com/android/phone/PhoneInterfaceManager.java
@@ -24,6 +24,7 @@ import android.content.Intent;
 import android.net.ConnectivityManager;
 import android.net.Uri;
 import android.os.AsyncResult;
+import android.os.Process;
 import android.os.Binder;
 import android.os.Bundle;
 import android.os.Handler;
@@ -44,9 +45,15 @@ import com.android.internal.telephony.ITelephony;
 import com.android.internal.telephony.Phone;
 import com.android.internal.telephony.CallManager;
 import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.uicc.IccIoResult;
+import com.android.internal.telephony.uicc.IccUtils;
+import com.android.internal.telephony.CommandException;
 
 import java.util.List;
 import java.util.ArrayList;
+import java.io.ByteArrayOutputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
 
 /**
  * Implementation of the ITelephony interface.
@@ -63,6 +70,14 @@ public class PhoneInterfaceManager extends ITelephony.Stub {
     private static final int CMD_ANSWER_RINGING_CALL = 4;
     private static final int CMD_END_CALL = 5;  // not used yet
     private static final int CMD_SILENCE_RINGER = 6;
+    private static final int CMD_EXCHANGE_APDU = 7;
+    private static final int EVENT_EXCHANGE_APDU_DONE = 8;
+    private static final int CMD_OPEN_CHANNEL = 9;
+    private static final int EVENT_OPEN_CHANNEL_DONE = 10;
+    private static final int CMD_CLOSE_CHANNEL = 11;
+    private static final int EVENT_CLOSE_CHANNEL_DONE = 12;
+    private static final int CMD_SIM_IO = 13;
+    private static final int EVENT_SIM_IO_DONE = 14;
 
     /** The singleton instance. */
     private static PhoneInterfaceManager sInstance;
@@ -73,6 +88,25 @@ public class PhoneInterfaceManager extends ITelephony.Stub {
     AppOpsManager mAppOps;
     MainThreadHandler mMainThreadHandler;
 
+    private int lastError;
+
+    private static final class IccAPDUArgument {
+
+        public int channel, cla, command, p1, p2, p3;
+        public String data;
+
+        public IccAPDUArgument(int cla, int command, int channel,
+                int p1, int p2, int p3, String data) {
+            this.channel = channel;
+            this.cla = cla;
+            this.command = command;
+            this.p1 = p1;
+            this.p2 = p2;
+            this.p3 = p3;
+            this.data = data;
+        }
+    }
+
     /**
      * A request object for use with {@link MainThreadHandler}. Requesters should wait() on the
      * request after sending. The main thread will notify the request when it is complete.
@@ -170,6 +204,141 @@ public class PhoneInterfaceManager extends ITelephony.Stub {
                     }
                     break;
 
+                case CMD_EXCHANGE_APDU:
+                    request = (MainThreadRequest) msg.obj;
+                    IccAPDUArgument argument =
+                            (IccAPDUArgument) request.argument;
+                    onCompleted = obtainMessage(EVENT_EXCHANGE_APDU_DONE,
+                            request);
+                    mPhone.getIccCard().exchangeAPDU(argument.cla,
+                            argument.command,
+                            argument.channel, argument.p1, argument.p2,
+                            argument.p3, argument.data, onCompleted);
+                    break;
+
+                case EVENT_EXCHANGE_APDU_DONE:
+                    ar = (AsyncResult) msg.obj;
+                    request = (MainThreadRequest) ar.userObj;
+                    if (ar.exception == null && ar.result != null) {
+                        request.result = ar.result;
+                        lastError = 0;
+                    } else {
+                        request.result = new IccIoResult(0x6f, 0,
+                                (byte[])null);
+                        lastError = 1;
+                        if ((ar.exception != null) &&
+                                (ar.exception instanceof CommandException)) {
+                            if (((CommandException)ar.exception)
+                                    .getCommandError() ==
+                                    CommandException.Error.INVALID_PARAMETER) {
+                                lastError = 5;
+                            }
+                        }
+                    }
+                    synchronized (request) {
+                        request.notifyAll();
+                    }
+                    break;
+
+                case CMD_OPEN_CHANNEL:
+                    request = (MainThreadRequest) msg.obj;
+                    onCompleted = obtainMessage(EVENT_OPEN_CHANNEL_DONE,
+                            request);
+                    mPhone.getIccCard().openLogicalChannel(
+                            (String)request.argument, onCompleted);
+                    break;
+
+                case EVENT_OPEN_CHANNEL_DONE:
+                    ar = (AsyncResult) msg.obj;
+                    request = (MainThreadRequest) ar.userObj;
+                    if (ar.exception == null && ar.result != null) {
+                        request.result = new Integer(((int[])ar.result)[0]);
+                        lastError = 0;
+                    } else {
+                        request.result = new Integer(0);
+                        lastError = 1;
+                        if ((ar.exception != null) &&
+                                (ar.exception instanceof CommandException)) {
+                            if (((CommandException)ar.exception)
+                                    .getCommandError() ==
+                                    CommandException.Error.MISSING_RESOURCE) {
+                                lastError = 2;
+                            } else {
+                                if (((CommandException)ar.exception)
+                                    .getCommandError() ==
+                                    CommandException.Error.NO_SUCH_ELEMENT) {
+                                    lastError = 3;
+                                }
+                            }
+                        }
+                    }
+                    synchronized (request) {
+                        request.notifyAll();
+                    }
+                    break;
+
+                case CMD_CLOSE_CHANNEL:
+                    request = (MainThreadRequest) msg.obj;
+                    onCompleted = obtainMessage(EVENT_CLOSE_CHANNEL_DONE,
+                            request);
+                    mPhone.getIccCard().closeLogicalChannel(
+                            ((Integer)request.argument).intValue(),
+                            onCompleted);
+                    break;
+
+                case EVENT_CLOSE_CHANNEL_DONE:
+                    ar = (AsyncResult) msg.obj;
+                    request = (MainThreadRequest) ar.userObj;
+                    if (ar.exception == null) {
+                        request.result = new Integer(0);
+                        lastError = 0;
+                    } else {
+                        request.result = new Integer(-1);
+                        lastError = 1;
+                        if ((ar.exception != null) &&
+                                (ar.exception instanceof CommandException)) {
+                            if (((CommandException)ar.exception)
+                                    .getCommandError() ==
+                                    CommandException.Error.INVALID_PARAMETER) {
+                                lastError = 5;
+                            }
+                        }
+                    }
+                    synchronized (request) {
+                        request.notifyAll();
+                    }
+                    break;
+
+               case CMD_SIM_IO:
+                    request = (MainThreadRequest) msg.obj;
+                    IccAPDUArgument parameters =
+                            (IccAPDUArgument) request.argument;
+                    onCompleted = obtainMessage(EVENT_SIM_IO_DONE,request);
+                    mPhone.getIccCard().exchangeSimIO( parameters.cla, /* fileID */
+                           parameters.command,
+                            parameters.p1, parameters.p2, parameters.p3,
+                            parameters.data, onCompleted);
+                    break;
+
+               case EVENT_SIM_IO_DONE:
+                    ar = (AsyncResult) msg.obj;
+                    request = (MainThreadRequest) ar.userObj;
+                    if (ar.exception == null && ar.result != null) {
+                        request.result = ar.result;
+                        lastError = 0;
+                    } else {
+                        request.result = new IccIoResult(0x6f, 0, (byte[])null);
+                        lastError = 1;
+                        if ((ar.exception != null) &&
+                                (ar.exception instanceof CommandException)) {
+                            if (((CommandException)ar.exception).getCommandError() ==
+                                    CommandException.Error.INVALID_PARAMETER) {
+                                lastError = 5;
+                    }}}
+                    synchronized (request) { request.notifyAll(); }
+                    break;
+
+
                 default:
                     Log.w(LOG_TAG, "MainThreadHandler: unexpected message code: " + msg.what);
                     break;
@@ -881,4 +1050,81 @@ public class PhoneInterfaceManager extends ITelephony.Stub {
     public int getLteOnCdmaMode() {
         return mPhone.getLteOnCdmaMode();
     }
+
+    private String exchangeIccAPDU(int cla, int command,
+            int channel, int p1, int p2, int p3, String data) {
+        if (Binder.getCallingUid() != Process.SMARTCARD_UID)
+            throw new SecurityException("Only Smartcard API may access UICC");
+        Log.d(LOG_TAG, "> exchangeAPDU " + channel + " " + cla + " " +
+                command + " " + p1 + " " + p2 + " " + p3 + " " + data);
+        IccIoResult response =
+                (IccIoResult)sendRequest(CMD_EXCHANGE_APDU,
+                        new IccAPDUArgument(cla, command, channel,
+                        p1, p2, p3, data));
+        Log.d(LOG_TAG, "< exchangeAPDU " + response);
+        String s = Integer.toHexString(
+                (response.sw1 << 8) + response.sw2 + 0x10000).substring(1);
+        if (response.payload != null)
+            s = IccUtils.bytesToHexString(response.payload) + s;
+        return s;
+    }
+
+    public String transmitIccBasicChannel(int cla, int command,
+            int p1, int p2, int p3, String data) {
+        return exchangeIccAPDU(cla, command, 0, p1, p2, p3, data);
+    }
+
+    public String transmitIccLogicalChannel(int cla, int command,
+            int channel, int p1, int p2, int p3, String data) {
+        return exchangeIccAPDU(cla, command, channel, p1, p2, p3, data);
+    }
+ 
+    public int openIccLogicalChannel(String AID) {
+        if (Binder.getCallingUid() != Process.SMARTCARD_UID)
+            throw new SecurityException("Only Smartcard API may access UICC");
+        Log.d(LOG_TAG, "> openIccLogicalChannel " + AID);
+        Integer channel = (Integer)sendRequest(CMD_OPEN_CHANNEL, AID);
+        Log.d(LOG_TAG, "< openIccLogicalChannel " + channel);
+        return channel.intValue();
+    }
+
+    public boolean closeIccLogicalChannel(int channel) {
+        if (Binder.getCallingUid() != Process.SMARTCARD_UID)
+            throw new SecurityException("Only Smartcard API may access UICC");
+        Log.d(LOG_TAG, "> closeIccLogicalChannel " + channel);
+        Integer err = (Integer)sendRequest(CMD_CLOSE_CHANNEL,
+                new Integer(channel));
+        Log.d(LOG_TAG, "< closeIccLogicalChannel " + err);
+        if(err.intValue() == 0)
+            return true;
+        return false;
+    }
+
+    public int getLastError() {
+        return lastError;
+    }
+    
+    public byte[] transmitIccSimIO(int fileID, int command,
+                                               int p1, int p2, int p3, String filePath) {
+        if (Binder.getCallingUid() != Process.SMARTCARD_UID)
+            throw new SecurityException("Only Smartcard API may access UICC");
+        Log.d(LOG_TAG, "Exchange SIM_IO " + fileID + ":" + command + " " +
+                 p1 + " " + p2 + " " + p3 + ":" + filePath);
+        IccIoResult response =
+                (IccIoResult)sendRequest(CMD_SIM_IO,
+                        new IccAPDUArgument(fileID, command, -1,
+                        p1, p2, p3, filePath));
+        Log.d(LOG_TAG, "Exchange SIM_IO [R]" + response);
+        byte[] result=null; int length=2;
+        if (response.payload != null) {
+            length=2+response.payload.length;
+            result=new byte[length];
+            System.arraycopy(response.payload,0,result,0,response.payload.length);
+        } else result=new byte[length];
+        Log.d(LOG_TAG,"Exchange SIM_IO [L] "+length);
+        result[length-1]=(byte)response.sw2;
+        result[length-2]=(byte)response.sw1;
+        return result;
+    }
+ 
 }
